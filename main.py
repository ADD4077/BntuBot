import os
import sys
import pytz
import asyncio
import aiosqlite
import datetime
import json
import hashlib
import logging

from aiogram.utils.markdown import hlink
from aiogram.types import ChosenInlineResult, InlineQuery, \
                          InlineQueryResultArticle, InputTextMessageContent
from aiogram.fsm.context import FSMContext
from aiogram import Bot, Dispatcher, types, flags, filters, F
from aiogram.filters.command import Command
from aiogram.exceptions import TelegramForbiddenError

from util.StateStorge import SQLiteStorage
from util import func
from util.literature_searching import search_literature
from util import middleware
from util.states import AutoAuth, AcceptAuthForm, AnonChatState, Form
from util import states
from util.config import server_db_path
from util import keyboards

from dotenv import load_dotenv

load_dotenv()

API_TOKEN = os.getenv('TOKEN')

main_menu_image = os.getenv('MAIN_IMAGE')
example_photo = os.getenv('EXAMPLE_IMAGE')
map_photo = os.getenv('MAP_IMAGE')

user_owner = os.getenv('USER_OWNER')
id_owner = int(os.getenv('ID_OWNER'))
moderators_chat_id = int(os.getenv("MODERATORS_CHAT_ID"))

bot = Bot(token=API_TOKEN)
dp = Dispatcher(storage=SQLiteStorage())
tz = pytz.timezone("Europe/Moscow")

logging.basicConfig(
    level=logging.INFO,
    format="[%(asctime)s] [%(name)s/%(levelname)s]: %(message)s",
    handlers=[
        logging.FileHandler(
            f"./logs/{__name__}_{datetime.datetime.now(tz).strftime('%d-%m-%Y_%H-%M-%S')}.log",
            mode="w"
        ),
        logging.StreamHandler(sys.stdout)
    ],
    force=True
)
logger = logging.getLogger(__name__)


def handle_exception(exc_type, exc_value, exc_traceback):
    if issubclass(exc_type, KeyboardInterrupt):
        sys.__excepthook__(exc_type, exc_value, exc_traceback)
        return
    logger.critical(
        "Uncaught exception:",
        exc_info=(exc_type, exc_value, exc_traceback)
    )


sys.excepthook = handle_exception
# with open('schedule.json', 'r', encoding="utf8") as json_file:
#     schedule_base = json.load(json_file)


with open("passes.json", "r", encoding="utf8") as jsonfile:
    passes = json.load(jsonfile)


with open("./books/literature.json", "r", encoding="utf8") as jsonfile:
    literature = json.load(jsonfile)


@dp.inline_query()
async def inline_handler(inline_query: InlineQuery):
    query = inline_query.query or ""
    books = search_literature(literature, query)
    results = []
    for id, book in enumerate(books):
        link = hlink('‚¨áÔ∏è –°–∫–∞—á–∞—Ç—å', book['download']['download_link'])
        description = book["publishing_date"]
        message_text = f"{book['publishing_date']} | {book['title']}\n\n{book['description']}\n\n{link}"
        if book["authors"]:
            with_authors = ' –∏ –¥—Ä.' if len(book["authors"]) != 1 else ''
            description += f" | {book['authors'][0]}{with_authors}"
            message_text = (
                f"<b>{book['publishing_date']} | {book['title']}</b>\n\n"
                f"<b>‚ÑπÔ∏è –û–ø–∏—Å–∞–Ω–∏–µ:</b>\n{book['description']}\n\n<b>¬©Ô∏è –ê–≤—Ç–æ—Ä—ã:</b>\n{book['authors'][0]}{with_authors}\n\n{link}"
            )
        results.append(InlineQueryResultArticle(
            id=str(id),
            title=book['title'],
            input_message_content=InputTextMessageContent(
                message_text=message_text,
                parse_mode="HTML"
            ),
            description=description,
            thumbnail_url=book["image_url"]
        ))
    await bot.answer_inline_query(inline_query.id, results)


@dp.chosen_inline_result()
async def chosen_inline_handler(result: ChosenInlineResult):
    print(result)


@dp.message(Command("start"))
@flags.authorization(is_authorized=True)
async def start(message: types.Message):
    await message.answer_photo(
            photo=main_menu_image,
            caption=f"üíö –†–∞–¥—ã –≤–∞—Å –≤–∏–¥–µ—Ç—å, @{message.from_user.username}!\n\nüß© –≠—Ç–æ –±–æ—Ç –∏–Ω–∂–µ–Ω–µ—Ä–Ω–æ-–ø–µ–¥–∞–≥–æ–≥–∏—á–µ—Å–∫–æ–≥–æ —Ñ–∞–∫—É–ª—å—Ç–µ—Ç–∞, –≥—Ä—É–ø–ø—ã –ø—Ä–∏–∫–ª–∞–¥–Ω–æ–≥–æ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è, –≤ –∫–æ—Ç–æ—Ä–æ–º –í—ã —Å–º–æ–∂–µ—Ç–µ –Ω–∞–π—Ç–∏ –ø–æ–ª–µ–∑–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é.\n\nüìó –ë–æ—Ç –ø–æ–º–æ–∂–µ—Ç –í–∞–º –±—ã—Å—Ç—Ä–æ –∏ –ø—Ä–æ—Å—Ç–æ –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ –≤–∞—à–µ–≥–æ —Ñ–∞–∫—É–ª—å—Ç–µ—Ç–∞ –Ω–∞ –±–ª–∏–∂–∞–π—à–∏–µ –ø–∞—Ä—É –¥–Ω–µ–π –∏–ª–∏ –ø–æ–ª–Ω–æ—Å—Ç—å—é, —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∞ –ø–æ —Ä–∞–∑–Ω—ã–º –ø—Ä–µ–¥–º–µ—Ç–∞–º, –∞ —Ç–∞–∫–∂–µ –ª–∏—Ç–µ—Ä–∞—Ç—É—Ä—É, –Ω—É–∂–Ω—É—é –¥–ª—è –æ—Å–≤–æ–µ–Ω–∏—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—ã—Ö –ø—Ä–µ–¥–º–µ—Ç–æ–≤.\n\nüçÄ –ü–æ—á–µ–º—É —Å—Ç–æ–∏—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –±–æ—Ç–æ–º?\n‚Ä¢ –ë—ã—Å—Ç—Ä–æ –∏ –Ω–µ –Ω—É–∂–Ω–æ –∂–¥–∞—Ç—å\n‚Ä¢ –ù–∞–¥—ë–∂–Ω–æ –∏ –±–µ–∑–æ–ø–∞—Å–Ω–æ\n‚Ä¢ –£–¥–æ–±–Ω–æ –∏ –ø—Ä–æ—Å—Ç–æ\n‚Ä¢ –ü—Ä–æ–≤–µ—Ä–µ–Ω–æ –¥—Ä—É–≥–∏–º–∏",
            reply_markup=keyboards.main_menu_buttons()
        )


@dp.callback_query(F.data == "main_menu")
@flags.authorization(is_authorized=True)
async def main_menu(callback: types.CallbackQuery):
    try:
        await callback.message.edit_caption(
            photo=main_menu_image,
            caption=f"üíö –†–∞–¥—ã –≤–∞—Å –≤–∏–¥–µ—Ç—å, @{callback.from_user.username}!\n\nüß© –≠—Ç–æ –±–æ—Ç –∏–Ω–∂–µ–Ω–µ—Ä–Ω–æ-–ø–µ–¥–∞–≥–æ–≥–∏—á–µ—Å–∫–æ–≥–æ —Ñ–∞–∫—É–ª—å—Ç–µ—Ç–∞, –≥—Ä—É–ø–ø—ã –ø—Ä–∏–∫–ª–∞–¥–Ω–æ–≥–æ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è, –≤ –∫–æ—Ç–æ—Ä–æ–º –í—ã —Å–º–æ–∂–µ—Ç–µ –Ω–∞–π—Ç–∏ –ø–æ–ª–µ–∑–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é.\n\nüìó –ë–æ—Ç –ø–æ–º–æ–∂–µ—Ç –í–∞–º –±—ã—Å—Ç—Ä–æ –∏ –ø—Ä–æ—Å—Ç–æ –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ –≤–∞—à–µ–≥–æ —Ñ–∞–∫—É–ª—å—Ç–µ—Ç–∞ –Ω–∞ –±–ª–∏–∂–∞–π—à–∏–µ –ø–∞—Ä—É –¥–Ω–µ–π –∏–ª–∏ –ø–æ–ª–Ω–æ—Å—Ç—å—é, —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∞ –ø–æ —Ä–∞–∑–Ω—ã–º –ø—Ä–µ–¥–º–µ—Ç–∞–º, –∞ —Ç–∞–∫–∂–µ –ª–∏—Ç–µ—Ä–∞—Ç—É—Ä—É, –Ω—É–∂–Ω—É—é –¥–ª—è –æ—Å–≤–æ–µ–Ω–∏—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—ã—Ö –ø—Ä–µ–¥–º–µ—Ç–æ–≤.\n\nüçÄ –ü–æ—á–µ–º—É —Å—Ç–æ–∏—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –±–æ—Ç–æ–º?\n‚Ä¢ –ë—ã—Å—Ç—Ä–æ –∏ –Ω–µ –Ω—É–∂–Ω–æ –∂–¥–∞—Ç—å\n‚Ä¢ –ù–∞–¥—ë–∂–Ω–æ –∏ –±–µ–∑–æ–ø–∞—Å–Ω–æ\n‚Ä¢ –£–¥–æ–±–Ω–æ –∏ –ø—Ä–æ—Å—Ç–æ\n‚Ä¢ –ü—Ä–æ–≤–µ—Ä–µ–Ω–æ –¥—Ä—É–≥–∏–º–∏",
            reply_markup=keyboards.main_menu_buttons()
        )
    # dont use bare except
    except Exception:
        await callback.message.delete()
        await callback.message.answer_photo(
                photo=main_menu_image,
                caption=f"üíö –†–∞–¥—ã –≤–∞—Å –≤–∏–¥–µ—Ç—å, @{callback.from_user.username}!\n\nüß© –≠—Ç–æ –±–æ—Ç –∏–Ω–∂–µ–Ω–µ—Ä–Ω–æ-–ø–µ–¥–∞–≥–æ–≥–∏—á–µ—Å–∫–æ–≥–æ —Ñ–∞–∫—É–ª—å—Ç–µ—Ç–∞, –≥—Ä—É–ø–ø—ã –ø—Ä–∏–∫–ª–∞–¥–Ω–æ–≥–æ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è, –≤ –∫–æ—Ç–æ—Ä–æ–º –í—ã —Å–º–æ–∂–µ—Ç–µ –Ω–∞–π—Ç–∏ –ø–æ–ª–µ–∑–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é.\n\nüìó –ë–æ—Ç –ø–æ–º–æ–∂–µ—Ç –í–∞–º –±—ã—Å—Ç—Ä–æ –∏ –ø—Ä–æ—Å—Ç–æ –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ –≤–∞—à–µ–≥–æ —Ñ–∞–∫—É–ª—å—Ç–µ—Ç–∞ –Ω–∞ –±–ª–∏–∂–∞–π—à–∏–µ –ø–∞—Ä—É –¥–Ω–µ–π –∏–ª–∏ –ø–æ–ª–Ω–æ—Å—Ç—å—é, —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∞ –ø–æ —Ä–∞–∑–Ω—ã–º –ø—Ä–µ–¥–º–µ—Ç–∞–º, –∞ —Ç–∞–∫–∂–µ –ª–∏—Ç–µ—Ä–∞—Ç—É—Ä—É, –Ω—É–∂–Ω—É—é –¥–ª—è –æ—Å–≤–æ–µ–Ω–∏—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—ã—Ö –ø—Ä–µ–¥–º–µ—Ç–æ–≤.\n\nüçÄ –ü–æ—á–µ–º—É —Å—Ç–æ–∏—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –±–æ—Ç–æ–º?\n‚Ä¢ –ë—ã—Å—Ç—Ä–æ –∏ –Ω–µ –Ω—É–∂–Ω–æ –∂–¥–∞—Ç—å\n‚Ä¢ –ù–∞–¥—ë–∂–Ω–æ –∏ –±–µ–∑–æ–ø–∞—Å–Ω–æ\n‚Ä¢ –£–¥–æ–±–Ω–æ –∏ –ø—Ä–æ—Å—Ç–æ\n‚Ä¢ –ü—Ä–æ–≤–µ—Ä–µ–Ω–æ –¥—Ä—É–≥–∏–º–∏",
                reply_markup=keyboards.main_menu_buttons()
            )


@dp.callback_query(F.data == "auto_auth")
async def auto_auth_begin(callback: types.CallbackQuery, state: FSMContext):
    await callback.message.delete()
    await callback.message.answer(
        "üß© –û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ç–µ–∫—Å—Ç–æ–º –Ω–æ–º–µ—Ä –í–∞—à–µ–≥–æ —Å—Ç—É–¥–µ–Ω—á–µ—Å–∫–æ–≥–æ –±–∏–ª–µ—Ç–∞ (—á—ë—Ä–Ω—ã–π). –ë–µ–∑ –ø—Ä–æ–±–µ–ª–æ–≤, –ª–∏—à–Ω–∏—Ö —Å–∏–º–≤–æ–ª–æ–≤, –∑–∞–ø—è—Ç—ã—Ö –∏ —Ç.–¥.",
    )
    await state.set_state(AutoAuth.student_code)


@dp.message(AutoAuth.student_code)
async def auto_auth_end(message: types.Message, state: FSMContext):
    await message.answer(
        "üß© –û—Ç–ª–∏—á–Ω–æ! –¢–µ–ø–µ—Ä—å —Ç–∞–∫–∂–µ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –∫—Ä–∞—Å–Ω—ã–π –Ω–æ–º–µ—Ä –Ω–∞ —Å—Ç—É–¥–µ–Ω—á–µ—Å–∫–æ–º.",
    )
    await state.update_data(student_code=message.text)
    await state.set_state(AutoAuth.code)


@dp.message(AutoAuth.code)
async def auto_auth_end(message: types.Message, state: FSMContext):
    data = await state.get_data()
    student_code = data.get("student_code")
    await state.clear()
    code = message.text
    auth_status = await func.authorize(student_code, code)
    if auth_status == -1:
        b_auth = types.InlineKeyboardButton(
            text="üîê –í—Ä—É—á–Ω—É—é",
            callback_data="support_auth"
        )
        await message.answer(
            '‚ö†Ô∏è –û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞. –°–∏—Å—Ç–µ–º–∞ –ë–ù–¢–£ –Ω–µ –æ—Ç–≤–µ—á–∞–µ—Ç. –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞, –Ω–æ –í—ã –º–æ–∂–µ—Ç–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞—Ç—å—Å—è –≤—Ä—É—á–Ω—É—é —á–µ—Ä–µ–∑ —Ñ–æ—Ç–æ –ø—Ä–æ—Ñ–∏–ª—è –ø–æ –∫–Ω–æ–ø–∫–µ "–í—Ä—É—á–Ω—É—é".',
            reply_markup=keyboards.auth_error()
        )
    elif auth_status == 0:
        await message.answer(
            "‚ùå –°—Ç—É–¥–µ–Ω—Ç —Å —Ç–∞–∫–∏–º–∏ –¥–∞–Ω–Ω—ã–º–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ —Å–∏—Å—Ç–µ–º–µ –ë–ù–¢–£. –í—ã –º–æ–∂–µ—Ç–µ –ø–æ–≤—Ç–æ—Ä–∏—Ç—å –ø–æ–ø—ã—Ç–∫—É, –Ω–∞–ø–∏—Å–∞–≤ /start.",
        )
    else:
        async with aiosqlite.connect(server_db_path) as db:
            async with db.cursor() as cursor:
                code = hashlib.sha256(code.encode()).hexdigest()
                await cursor.execute(
                    "INSERT INTO users VALUES (?, ?, ?, ?, ?)",
                    (message.from_user.id, auth_status[0], auth_status[1], student_code, code)
                )
            await db.commit()
        await message.answer(f'‚úÖ {auth_status[0]}, –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –ø—Ä–æ—à–ª–∞ —É—Å–ø–µ—à–Ω–æ! –¢–µ–ø–µ—Ä—å –í—ã –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–Ω—ã–π —Å—Ç—É–¥–µ–Ω—Ç –ë–ù–¢–£! –í—ã –º–æ–∂–µ—Ç–µ –≤—ã–∑–≤–∞—Ç—å –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é –∫–æ–º–∞–Ω–¥–æ–π /start')
        await bot.send_message(
            id_owner, f'‚úÖ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω @{message.from_user.username} ({message.from_user.full_name}).'
        )


@dp.callback_query(F.data == "support_auth")
async def auth_begin(callback: types.CallbackQuery, state: FSMContext):
    await callback.message.delete()
    await callback.message.answer_photo(
        photo=example_photo,
        caption="üì∑ –û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–æ—Ç–æ –í–∞—à–µ–≥–æ —Å—Ç—É–¥–µ–Ω—á–µ—Å–∫–æ–≥–æ –±–∏–ª–µ—Ç–∞, —á—Ç–æ–±—ã –º—ã –º–æ–≥–ª–∏ —É–±–µ–¥–∏—Ç—å—Å—è –≤ —Ç–æ–º, —á—Ç–æ –í—ã —è–≤–ª—è–µ—Ç–µ—Å—å –Ω–∞—à–∏–º —Å—Ç—É–¥–µ–Ω—Ç–æ–º. –§–æ—Ç–æ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å —á—ë—Ç–∫–∏–º, –≤ —Ö–æ—Ä–æ—à–µ–º –æ—Å–≤–µ—â–µ–Ω–∏–∏ –∏ –±–µ–∑ –±–ª–∏–∫–æ–≤.",
    )
    await state.set_state(Form.photo)


@dp.message(Form.photo)
async def auth_end(message: types.Message, state: FSMContext):
    if not message.photo:
        return await message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –∏–º–µ–Ω–Ω–æ —Ñ–æ—Ç–æ.")
    photo = message.photo[-1]
    await bot.send_photo(
        id_owner,
        photo=photo.file_id,
        caption=f"–§–æ—Ç–æ —Å—Ç—É–¥–µ–Ω—á–µ—Å–∫–æ–≥–æ –±–∏–ª–µ—Ç–∞ –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è @{message.from_user.username} (ID: {message.from_user.id})",
        reply_markup=keyboards.support_auth(message.from_user.id)
    )
    await message.answer("–§–æ—Ç–æ –ø–æ–ª—É—á–µ–Ω–æ –∏ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –Ω–∞ –ø—Ä–æ–≤–µ—Ä–∫—É. –û–∂–∏–¥–∞–π—Ç–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è.")
    await state.clear()


@dp.callback_query(F.data.split()[0] == "accept_auth")
async def accept_auth(callback: types.CallbackQuery, state: FSMContext):
    await callback.message.edit_caption(
        caption="–í–≤–µ–¥–∏—Ç–µ –¥–∞–Ω–Ω—ã–µ —á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é: –§–ò–û, –§–∞–∫—É–ª—å—Ç–µ—Ç, –ö–æ–¥ —Å—Ç—É–¥–µ–Ω—Ç–∞ (—á–µ—Ä–Ω—ã–π), –ö–æ–¥ –±–∏–ª–µ—Ç–∞ (–∫—Ä–∞—Å–Ω—ã–π)."
    )
    await state.set_state(AcceptAuthForm.id)
    await state.update_data(id=int(callback.data.split()[1]))
    await state.set_state(AcceptAuthForm.text)


@dp.message(AcceptAuthForm.text)
async def accept_auth_2(message: types.Message, state: FSMContext):
    data = await state.get_data()
    id = data.get("id")
    await state.clear()
    fio = message.text.split(',')[0]
    fac = message.text.split(',')[1].replace(' ', '')
    student_code = message.text.split(',')[2]
    bilet_code = message.text.split(',')[3]
    code = hashlib.sha256(bilet_code.encode()).hexdigest()
    async with aiosqlite.connect(server_db_path) as db:
        async with db.cursor() as cursor:
            await cursor.execute(
                "INSERT INTO users VALUES (?, ?, ?, ?, ?)",
                (id, fio, fac, student_code, code)
            )
        await db.commit()
    await message.answer("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –±—ã–ª —É—Å–ø–µ—à–Ω–æ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω.")
    await bot.send_message(
        id, f'‚úÖ {fio.split()[1]}, –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –±—ã–ª–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞, —Ç–µ–ø–µ—Ä—å –í—ã –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–Ω—ã–π —Å—Ç—É–¥–µ–Ω—Ç –ë–ù–¢–£! –í—ã –º–æ–∂–µ—Ç–µ –≤—ã–∑–≤–∞—Ç—å –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é –∫–æ–º–∞–Ω–¥–æ–π /start'
    )


@dp.callback_query(F.data == "anonymous_chat")
@flags.authorization(is_authorized=True)
async def anonymous_chat(callback: types.CallbackQuery):
    await callback.message.delete()
    await callback.message.answer(
        text=(
            "üïµüèª‚Äç‚ôÇÔ∏è –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –∞–Ω–æ–Ω–∏–º–Ω—ã–π —á–∞—Ç –ë–ù–¢–£. "
            "–ó–¥–µ—Å—å –í—ã –º–æ–∂–µ—Ç–µ –Ω–∞–π—Ç–∏ —Å–µ–±–µ —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫–∞ –¥–ª—è —Ç–æ–≥–æ, "
            "—á—Ç–æ–±—ã —Å–∫–æ—Ä–æ—Ç–∞—Ç—å –≤—Ä–µ–º—è –Ω–∞ —Å–∫—É—á–Ω–æ–π –ø–∞—Ä–µ –∏–ª–∏ –ø—Ä–æ—Å—Ç–æ "
            "–ø–æ–≤–µ—Å–µ–ª–∏—Ç—å—Å—è –æ–±—â–∞—è—Å—å —Å –¥—Ä—É–≥–∏–º–∏ —Å—Ç—É–¥–µ–Ω—Ç–∞–º–∏ —Å–≤–æ–µ–≥–æ "
            "—É–Ω–∏–≤–µ—Ä—Å–∏—Ç–µ—Ç–∞. –¢–∞–∫–∂–µ –Ω–µ –±—É–¥–µ—Ç –ª–∏—à–Ω–∏–º –Ω–∞–π—Ç–∏ –Ω–æ–≤—ã–µ "
            "–∑–Ω–∞–∫–æ–º—Å—Ç–≤–∞.\n\n‚ö†Ô∏è –ü–µ—Ä–µ–¥ —Ç–µ–º, –∫–∞–∫ –Ω–∞—á–∞—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è "
            "–∞–Ω–æ–Ω–∏–º–Ω—ã–º —á–∞—Ç–æ–º, –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –ø—Ä–æ—á–∏—Ç–∞–π –ø—Ä–∞–≤–∏–ª–∞.\n\n"
            "–ï—Å–ª–∏ –≤—ã —Ö–æ—Ç–∏—Ç–µ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å—Å—è –Ω–∞ –Ω–∞—Ä—É—à–µ–Ω–∏–µ –ø—Ä–∞–≤–∏–ª, "
            "–æ—Ç–≤–µ—Ç—å—Ç–µ –Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –Ω–∞—Ä—É—à–µ–Ω–∏–µ–º –∫–æ–º–º–∞–Ω–¥–æ–π /report\n\n"
            "–ß—Ç–æ–±—ã –≤—ã–π—Ç–∏ –∏–∑ –¥–∏–∞–ª–æ–≥–∞, –Ω–∞–ø–∏—à–∏—Ç–µ –≤ —á–∞—Ç –∫–æ–º–∞–Ω–¥—É /leave_chat\n\n"
            "üíö –ü—Ä–∏—è—Ç–Ω–æ–≥–æ –≤—Ä–µ–º—è –ø—Ä–æ–≤–æ–∂–¥–µ–Ω–∏—è!"
        ), 
        reply_markup=keyboards.anonymous_chat_menu()
    )


@dp.callback_query(F.data == "search_anonymous_chat")
@flags.banned(isnt_banned=True)
@flags.authorization(is_authorized=True)
async def search_anonymous_chat(callback: types.CallbackQuery, state: FSMContext):
    user2_id = callback.from_user.id
    async with aiosqlite.connect(server_db_path) as db:
        async with db.cursor() as cursor:
            if await (await cursor.execute(
                "SELECT user1_id, user2_id FROM chats WHERE user1_id = (?) OR user2_id = (?)",
                (user2_id, user2_id)
            )).fetchone():
                return await callback.message.edit_text(
                    "‚ùóÔ∏è –í—ã —É–∂–µ –≤ –∞–Ω–æ–Ω–∏–º–Ω–æ–º —á–∞—Ç–µ."
                )
            if user1_id := (await (await cursor.execute(
                "SELECT user1_id FROM chats WHERE user2_id IS NULL"
            )).fetchone()):
                user1_id = user1_id[0]
                await cursor.execute(
                    "UPDATE chats SET user2_id=(?) WHERE user1_id=(?)",
                    (user2_id, user1_id)
                )
                await callback.message.edit_text(
                    "üë• –°–æ–±–µ—Å–µ–¥–Ω–∏–∫ –Ω–∞–π–¥–µ–Ω."
                )
                await bot.send_message(
                    user1_id,
                    "üë• –°–æ–±–µ—Å–µ–¥–Ω–∏–∫ –Ω–∞–π–¥–µ–Ω."
                )
            else:
                await cursor.execute(
                    "INSERT INTO chats (user1_id, user2_id) VALUES (?, ?)",
                    (user2_id, None)
                )
                await callback.message.edit_text(
                    "üîé –ò–¥–µ—Ç –ø–æ–∏—Å–∫ —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫–∞."
                )
        await state.set_state(AnonChatState.in_chat)
        await db.commit()


@dp.message(Command("report"))
@flags.authorization(is_authorized=True)
async def report(message: types.Message):
    if reply_message := message.reply_to_message:
        message_id = reply_message.message_id
        user_id = reply_message.from_user.id
        if user_id == message.from_user.id:
            return message.answer("–í—ã –Ω–µ –º–æ–∂–µ—Ç–µ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å—Å—è –Ω–∞ —Å–µ–±—è")
        async with aiosqlite.connect(server_db_path) as db:
            async with db.cursor() as cursor:
                if data := await (await cursor.execute(
                    "SELECT user_id, chat_id FROM messages WHERE bot_message_id = (?)",
                    (message_id, )
                )).fetchone():
                    reported_user_id, anon_chat_id = data
                    await bot.send_message(
                        moderators_chat_id,
                        (
                            f"–ñ–∞–ª–æ–±–∞ –Ω–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ID: {reported_user_id}\n"
                            f"–û—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {message.from_user.username}"
                        ),
                        reply_markup=keyboards.report_menu(
                            reported_user_id, message.from_user.id
                        )
                    )
                    await func.send_message(
                        bot,
                        moderators_chat_id,
                        reply_message,
                        anon_chat_id,
                        is_report=True
                    )
                    return message.answer("–ñ–∞–ª–æ–±–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞")
                return message.answer("–ù—É–∂–Ω–æ –æ—Ç–≤–µ—á–∞—Ç—å –Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏–µ –∏–∑ –¥–∏–∞–ª–æ–≥–∞")
    message.answer("–í—ã –¥–æ–ª–∂–Ω—ã –æ—Ç–≤–µ—Ç–∏—Ç—å –Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –Ω–∞—Ä—É—à–µ–Ω–∏–µ–º —ç—Ç–æ–π –∫–æ–º–º–∞–Ω–¥–æ–π")


async def admin_panel(message, state=None):
    if state:
        await state.clear()
    is_callback = isinstance(message, types.CallbackQuery)
    if is_callback:
        message = message.message
    async with aiosqlite.connect(server_db_path) as db:
        async with db.cursor() as cursor:
            count = (await (await cursor.execute("SELECT COUNT(id) FROM users")).fetchone())[0]
            faculties = await (await cursor.execute("SELECT faculty FROM users")).fetchall()
    if is_callback:
        return await message.edit_text(
            f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: {count}\n"
            f"–§–∞–∫—É–ª—å—Ç–µ—Ç–æ–≤: {len(set(faculties))}",
            reply_markup=keyboards.admin_panel_menu()
        )
    await message.answer(
        f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: {count}\n"
        f"–§–∞–∫—É–ª—å—Ç–µ—Ç–æ–≤: {len(set(faculties))}",
        reply_markup=keyboards.admin_panel_menu()
    )


@dp.message(Command("admin"))
@flags.owner(is_owner=True)
@flags.permissions(any_permission=True)
@flags.authorization(is_authorized=True)
async def admin_panel_by_callback(message: types.Message, state: FSMContext):
    await admin_panel(message, state)


@dp.callback_query(F.data.contains("admin_panel"))
@flags.owner(is_owner=True)
@flags.permissions(any_permission=True)
@flags.authorization(is_authorized=True)
async def admin_panel_by_callback(callback: types.CallbackQuery, state: FSMContext):
    await admin_panel(callback, state)


@dp.callback_query(F.data == "search_user")
@flags.owner(is_owner=True)
@flags.permissions(any_permission=True)
@flags.authorization(is_authorized=True)
async def search_user(callback: types.CallbackQuery):
    await callback.message.edit_text(
        "–í—ã–±–µ—Ä–∏—Ç–µ —Å–ø–æ—Å–æ–± –ø–æ–∏—Å–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è:",
        reply_markup=keyboards.search_user_buttons()
    )


@dp.callback_query(F.data == "search_by_user_id")
@flags.owner(is_owner=True)
@flags.permissions(any_permission=True)
@flags.authorization(is_authorized=True)
async def search_by_user_id(callback: types.CallbackQuery, state: FSMContext):
    await state.set_state(states.InputUserID.InputByUserID)
    await callback.message.edit_text("–û—Ç–ø—Ä–∞–≤—å—Ç–µ Telegram ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è")


@dp.callback_query(F.data == "search_by_group_number")
@flags.owner(is_owner=True)
@flags.permissions(any_permission=True)
@flags.authorization(is_authorized=True)
async def search_by_group_number(callback: types.CallbackQuery, state: FSMContext):
    await state.set_state(states.InputUserID.InputByGroupNumber)
    await callback.message.edit_text("–û—Ç–ø—Ä–∞–≤—å—Ç–µ –Ω–æ–º–µ—Ä —Å—Ç—É–¥–µ–Ω—á–µ—Å–∫–æ–≥–æ –±–∏–ª–µ—Ç–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è")


@dp.message(states.InputUserID.InputByUserID)
async def input_user_id(message: types.Message, state: FSMContext):
    await state.clear()
    try:
        user_id = int(message.text)
    except ValueError:
        await state.clear()
        return await message.answer(
            "–í–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ —á–∏—Å–ª–æ.",
            reply_markup=keyboards.back_to_admin_panel()
        )
    async with aiosqlite.connect(server_db_path) as db:
        async with db.cursor() as cursor:
            response = await (await cursor.execute(
                "SELECT student_code, FullName, faculty FROM users WHERE id = ?",
                (user_id, )
            )).fetchone()
    if not response:
        return await message.answer(
            "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω",
            reply_markup=keyboards.back_to_admin_panel()
        )
    text = "–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ:\n\n"
    info_lines = ["–ù–æ–º–µ—Ä —Å—Ç—É–¥.–±–∏–ª–µ—Ç–∞:", "–§–∞–º–∏–ª–∏—è –∏ –∏–º—è:", "–§–∞–∫—É–ª—å—Ç–µ—Ç:"]
    for info_line, info in zip(info_lines, response):
        text += f"{info_line}\n<blockquote>{info}</blockquote>\n\n"
    await message.answer(
        text.rstrip("\n"),
        reply_markup=keyboards.control_user_buttons(user_id),
        parse_mode="HTML"
    )


@dp.callback_query(F.data.split()[0] == "send_message_for_user")
@flags.owner(is_owner=True)
@flags.permissions(any_permission=True)
@flags.authorization(is_authorized=True)
async def send_message_for_user(callback: types.CallbackQuery, state: FSMContext):
    await callback.message.edit_text(f'–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ, –∫–æ—Ç–æ—Ä–æ–µ —Ö–æ—Ç–∏—Ç–µ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é —Å ID: {callback.data.split()[1]}')
    await state.set_state(states.InputMessageForUser.user_id)
    await state.update_data(user_id=int(callback.data.split()[1]))
    await state.set_state(states.InputMessageForUser.message)


@dp.callback_query(F.data.split()[0] == "send_message_for_group")
@flags.owner(is_owner=True)
@flags.permissions(any_permission=True)
@flags.authorization(is_authorized=True)
async def send_message_for_group(callback: types.CallbackQuery, state: FSMContext):
    await callback.message.edit_text(f'–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ, –∫–æ—Ç–æ—Ä–æ–µ —Ö–æ—Ç–∏—Ç–µ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –≥—Ä—É–ø–ø–µ {callback.data.split()[1]}')
    await state.set_state(states.InputMessageForGroup.group_id)
    await state.update_data(group_id=int(callback.data.split()[1]))
    await state.set_state(states.InputMessageForGroup.message)


@dp.message(states.InputMessageForGroup.message)
async def input_send_message_for_user(message: types.Message, state: FSMContext):
    data = await state.get_data()
    group_number = data.get("group_id")
    await state.clear()
    async with aiosqlite.connect(server_db_path) as db:
        async with db.cursor() as cursor:
            users = await (await cursor.execute(
                "SELECT id FROM users WHERE substr(student_code, 1, length(student_code) - 2) = ?",
                (str(group_number),)
            )).fetchall()
    sending=0
    banned=0
    for user_id in users:
        try:
            await bot.send_message(chat_id=user_id[0], text=f"–°–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞:\n{message.text}")
            sending+=1
        except TelegramForbiddenError as e:
            if "bot was blocked by the user" in str(e):
                banned+=1
    await message.answer(
        f'–†–∞—Å—Å—ã–ª–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º –≥—Ä—É–ø–ø—ã {group_number} –∑–∞–≤–µ—Ä—à–µ–Ω–∞!\n\n'
        f'–û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ: {sending}\n'
        f'–ó–∞–±–∞–Ω–∏–ª–∏: {banned}\n'
        f'–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ: {len(users) - (sending+banned)}\n'
        )


@dp.message(states.InputMessageForUser.message)
async def input_send_message_for_user(message: types.Message, state: FSMContext):
    data = await state.get_data()
    user_id = data.get("user_id")
    await state.clear()
    try:
        await bot.send_message(chat_id=user_id, text=f"–°–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞:\n{message.text}")
    except TelegramForbiddenError as e:
        if "bot was blocked by the user" in str(e):
            return await message.answer(f'–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–ª –±–æ—Ç–∞.')
    await message.answer(f'–°–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é!')
    

@dp.message(states.InputUserID.InputByGroupNumber)
async def input_group_number(message: types.Message, state: FSMContext):
    await state.clear()
    try:
        group_number = int(message.text)
    except ValueError:
        await state.clear()
        return await message.answer(
            "–í–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ —á–∏—Å–ª–æ.",
            reply_markup=keyboards.back_to_admin_panel()
        )
    async with aiosqlite.connect(server_db_path) as db:
        async with db.cursor() as cursor:
            response = await (await cursor.execute(
                "SELECT id, FullName, faculty FROM users WHERE student_code = ?",
                (group_number, )
            )).fetchone()
    if not response:
        return await message.answer(
            "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω",
            reply_markup=keyboards.back_to_admin_panel()
        )
    text = "–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ:\n\n"
    info_lines = ["ID —Ç–µ–ª–µ–≥—Ä–∞–º –∞–∫–∫–∞—É–Ω—Ç–∞:", "–§–∞–º–∏–ª–∏—è –∏ –∏–º—è:", "–§–∞–∫—É–ª—å—Ç–µ—Ç:"]
    for info_line, info in zip(info_lines, response):
        text += f"{info_line}\n<blockquote>{info}</blockquote>\n\n"
    return await message.answer(
        text.rstrip("\n"),
        reply_markup=keyboards.control_user_buttons(response[0]),
        parse_mode="HTML"
    )


@dp.callback_query(F.data == "search_group")
@flags.owner(is_owner=True)
@flags.permissions(any_permission=True)
@flags.authorization(is_authorized=True)
async def search_group_input(callback: types.CallbackQuery, state: FSMContext):
    await state.set_state(states.InputGroupNumber.userInput)
    return await callback.message.edit_text(
        "–û—Ç–ø—Ä–∞–≤—å—Ç–µ –Ω–æ–º–µ—Ä –≥—Ä—É–ø–ø—ã:",
        reply_markup=keyboards.back_to_admin_panel()
    )


@dp.message(states.InputGroupNumber.userInput)
async def search_group(message: types.Message, state: FSMContext):
    group_number = message.text
    async with aiosqlite.connect(server_db_path) as db:
        async with db.cursor() as cursor:
            response = await (await cursor.execute(
                "SELECT id, student_code, FullName, faculty "
                "FROM users WHERE CAST(student_code AS TEXT) LIKE (?)",
                (group_number+"%", )
            )).fetchall()
    if not response:
        return await message.answer(
            "–ù–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤",
            reply_markup=keyboards.back_to_admin_panel()
        )
    users_amount = len(response)
    faculty = response[0][-1]
    text = (
        f"–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –≥—Ä—É–ø–ø–µ {group_number}:\n"
        f"–ö–æ–ª-–≤–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: {users_amount}\n"
        f"–§–∞–∫—É–ª—å—Ç–µ—Ç: {faculty}\n\n"
        "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏:\n"
    )
    text += "\n".join(
        [
            f"{i+1}. {info[2]} (Telegram ID: {info[0]}; –ù–æ–º–µ—Ä —Å—Ç—É–¥. –±–∏–ª–µ—Ç–∞: {info[1]})"
            for i, info in enumerate(response)
        ]
    )
    await message.answer(
        text,
        reply_markup=keyboards.control_group_buttons(group_number)
    )


@dp.callback_query(F.data == "search_faculty")
@flags.owner(is_owner=True)
@flags.permissions(any_permission=True)
@flags.authorization(is_authorized=True)
async def search_faculty_input(callback: types.CallbackQuery):
    await callback.message.edit_text(
        "–ò—Å–∫–∞—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –∏–∑ —Ñ–∞–∫—É–ª—å—Ç–µ—Ç–∞:",
        reply_markup=keyboards.search_faculty_buttons()
    )


@dp.callback_query(F.data == "search_by_faculty_abbr")
@flags.owner(is_owner=True)
@flags.permissions(any_permission=True)
@flags.authorization(is_authorized=True)
async def search_by_faculty_abbr(callback: types.CallbackQuery, state: FSMContext):
    await state.set_state(states.InputFaculty.InputByLetters)
    await callback.message.edit_text(
        "–í–≤–µ–¥–∏—Ç–µ –∞–±–±—Ä–µ–≤–∏–∞—Ç—É—Ä—É —Ñ–∞–∫—É–ª—å—Ç–µ—Ç–∞:",
        reply_markup=keyboards.back_to_admin_panel()
    )


@dp.callback_query(F.data == "search_by_faculty_number")
@flags.owner(is_owner=True)
@flags.permissions(any_permission=True)
@flags.authorization(is_authorized=True)
async def search_by_faculty_number(callback: types.CallbackQuery, state: FSMContext):
    await state.set_state(states.InputFaculty.InputByNumbers)
    return await callback.message.edit_text(
        "–í–≤–µ–¥–∏—Ç–µ –Ω–æ–º–µ—Ä —Ñ–∞–∫—É–ª—å—Ç–µ—Ç–∞:",
        reply_markup=keyboards.back_to_admin_panel()
    )


@dp.message(states.InputFaculty.InputByLetters)
async def input_faculty_abbr(message: types.Message, state: FSMContext):
    await state.clear()
    abbr = message.text.upper()
    async with aiosqlite.connect(server_db_path) as db:
        async with db.cursor() as cursor:
            response = await (await cursor.execute(
                "SELECT id, FullName "
                "FROM users WHERE faculty = (?)",
                (abbr, )
            )).fetchall()
    if not response:
        return await message.answer(
            "–ù–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤",
            reply_markup=keyboards.back_to_admin_panel()
        )
    users_amount = len(response)
    text = (
        f'–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Ñ–∞–∫—É–ª—å—Ç–µ—Ç–µ "{abbr}":\n'
        f"–ö–æ–ª-–≤–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: {users_amount}"
    )
    await message.answer(
        text,
        reply_markup=keyboards.back_to_admin_panel()
    )


@dp.message(states.InputFaculty.InputByNumbers)
async def input_faculty_numbers(message: types.Message, state: FSMContext):
    await state.clear()
    faculty = message.text
    if len(faculty) != 3:
        return await message.answer(
            "–ù–æ–º–µ—Ä —Ñ–∞–∫—É–ª—å—Ç–µ—Ç–∞ –¥–æ–ª–∂–µ–Ω —Å–æ—Å—Ç–æ—è—Ç—å –∏–∑ —Ç—Ä–µ—Ö —Ü–∏—Ñ—Ä",
            reply_markup=keyboards.back_to_admin_panel()
        )
    async with aiosqlite.connect(server_db_path) as db:
        async with db.cursor() as cursor:
            response = await (await cursor.execute(
                "SELECT id, FullName, faculty "
                "FROM users WHERE CAST(student_code AS TEXT) LIKE (?)",
                (faculty+"%", )
            )).fetchall()
    if not response:
        return await message.answer(
            "–ù–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤",
            reply_markup=keyboards.back_to_admin_panel()
        )
    users_amount = len(response)
    faculty_abbr = response[0][-1]
    text = (
        f'–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Ñ–∞–∫—É–ª—å—Ç–µ—Ç–µ "{faculty_abbr}":\n'
        f"–ö–æ–ª-–≤–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: {users_amount}"
    )
    await message.answer(
        text,
        reply_markup=keyboards.back_to_admin_panel()
    )


@dp.callback_query(F.data == "admin_schedule")
@flags.owner(is_owner=True)
@flags.permissions(any_permission=True)
@flags.authorization(is_authorized=True)
async def admin_schedule(callback: types.CallbackQuery):
    schedule_files = os.listdir("./schedules/")
    sorted_by_modification_time = sorted(
        schedule_files,
        key=lambda entry: os.path.getmtime(
            os.path.join("./schedules/", entry)
        ),
        reverse=True
    )
    newest_modification = datetime.datetime.fromtimestamp(
        os.path.getmtime(
            os.path.join(
                "./schedules/",
                sorted_by_modification_time[0]
            )
        ),
        pytz.timezone("Europe/Moscow")
    ).strftime("%d.%m.%Y %H:%M:%S")
    oldest_modificatiom = datetime.datetime.fromtimestamp(
        os.path.getmtime(
            os.path.join(
                "./schedules/",
                sorted_by_modification_time[-1]
            )
        ),
        pytz.timezone("Europe/Moscow")
    ).strftime("%d.%m.%Y %H:%M:%S")
    await callback.message.edit_text(
        f"–°–∞–º–æ–µ –ø–æ—Å–ª–µ–¥–Ω–µ–µ –∏–∑–º–µ–Ω–µ–Ω–∏–µ: {newest_modification} ({sorted_by_modification_time[0]})\n"
        f"–°–∞–º–æ–µ –¥–∞–≤–Ω–µ–µ –∏–∑–º–µ–Ω–µ–Ω–∏–µ: {oldest_modificatiom} ({sorted_by_modification_time[-1]})",
        reply_markup=keyboards.back_to_admin_panel()
    )


@dp.callback_query(F.data == "admin_literature")
@flags.owner(is_owner=True)
@flags.permissions(any_permission=True)
@flags.authorization(is_authorized=True)
async def admin_literature(callback: types.CallbackQuery):
    modification_time = datetime.datetime.fromtimestamp(
        os.path.getmtime(
            "./books/literature.json"
        ),
        pytz.timezone("Europe/Moscow")
    ).strftime("%d.%m.%Y %H:%M:%S")
    count = 0
    for _, books in literature.items():
        count += int(books["count"][1:-1])
    await callback.message.edit_text(
        f"–ü–æ—Å–ª–µ–¥–Ω–µ–µ –∏–∑–º–µ–Ω–µ–Ω–∏–µ –ª–∏—Ç–µ—Ä–∞—Ç—É—Ä—ã: {modification_time}\n"
        f"–ö–æ–ª-–≤–æ –∫–Ω–∏–≥: {count}",
        reply_markup=keyboards.back_to_admin_panel()
    )


@dp.callback_query(F.data.contains("ban_user"))
@flags.owner(is_owner=True)
@flags.moderator(is_moderator=True)
@flags.permissions(any_permission=True)
@flags.authorization(is_authorized=True)
async def button_ban_user(callback: types.CallbackQuery):
    user_id = int(callback.data.split(" ")[1])
    async with aiosqlite.connect(server_db_path) as db:
        async with db.cursor() as cursor:
            await cursor.execute(
                "INSERT INTO bans_anon_chat (user_id) VALUES (?)",
                (user_id, )
            )
            await db.commit()
    await callback.message.edit_text(
        f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å ID: {user_id} –∑–∞–±–∞–Ω–µ–Ω",
    )


@dp.message(Command("ban_user"))
@flags.owner(is_owner=True)
@flags.moderator(is_moderator=True)
@flags.permissions(any_permission=True)
@flags.authorization(is_authorized=True)
async def ban_user(message, command: filters.Command):
    if not command.args:
        return message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞ —É–∫–∞–∂–∏—Ç–µ ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è")
    user_id = int(command.args)
    async with aiosqlite.connect(server_db_path) as db:
        async with db.cursor() as cursor:
            await cursor.execute(
                "INSERT INTO bans_anon_chat (user_id) VALUES (?)",
                (user_id, )
            )
            await db.commit()
    await message.answer("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω")


@dp.message(Command("unban_user"))
@flags.owner(is_owner=True)
@flags.moderator(is_moderator=True)
@flags.permissions(any_permission=True)
@flags.authorization(is_authorized=True)
async def unban_user(message, command: filters.Command):
    if not command.args:
        return message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞ —É–∫–∞–∂–∏—Ç–µ ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è")
    user_id = int(command.args)
    async with aiosqlite.connect(server_db_path) as db:
        async with db.cursor() as cursor:
            await cursor.execute(
                "DELETE FROM bans_anon_chat WHERE user_id = (?)",
                (user_id, )
            )
            await db.commit()
    await message.answer("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω")


@dp.pre_checkout_query()
async def on_pre_checkout_query(pre_checkout_query: types.PreCheckoutQuery,):
    await pre_checkout_query.answer(ok=True)


@dp.message(F.successful_payment)
async def on_payment(message: types.Message):
    if message.successful_payment.invoice_payload == "unban_payment":
        user_id = message.from_user.id
        async with aiosqlite.connect(server_db_path) as db:
            async with db.cursor() as cursor:
                await cursor.execute(
                    "DELETE FROM bans_anon_chat WHERE user_id = (?)",
                    (user_id, )
                )
                await db.commit()
        await message.answer(
            "–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º —Å —É—Å–ø–µ—à–Ω—ã–º –ø—Ä–∏–æ–±—Ä–µ—Ç–µ–Ω–∏–µ–º —Ä–∞–∑–±–ª–æ–∫–∏–æ—Ä–≤–∫–∏!",
            message_effect_id="5104841245755180586"
        )


@dp.message(Command("leave_chat"))
@flags.authorization(is_authorized=True)
async def leave_chat(callback: types.CallbackQuery, state: FSMContext):
    user_id = callback.from_user.id
    async with aiosqlite.connect(server_db_path) as db:
        async with db.cursor() as cursor:
            if user_ids := await (await cursor.execute(
                "SELECT user1_id, user2_id, id FROM chats WHERE user1_id = (?) OR user2_id = (?)",
                (user_id, user_id)
            )).fetchone():
                for i in range(2):
                    if user_ids[i]:
                        await bot.send_message(
                            user_ids[i], 
                            "‚õîÔ∏è –î–∏–∞–ª–æ–≥ –æ–∫–æ–Ω—á–µ–Ω.",
                            reply_markup=keyboards.anonymous_chat_menu()
                        )
                await cursor.execute(
                    "DELETE FROM chats WHERE user1_id = (?) OR user2_id = (?)",
                    (user_id, user_id)
                )
                await state.clear()
        await db.commit()


@dp.message(AnonChatState.in_chat)
@flags.banned(isnt_banned=True)
async def on_message(message: types.message.Message, **kwargs):
    if message.via_bot:
        return
    media_group = kwargs.get("media_group")
    user_id = message.from_user.id
    async with aiosqlite.connect(server_db_path) as db:
        async with db.cursor() as cursor:
            if user_ids := await (await cursor.execute(
                "SELECT user1_id, user2_id, id FROM chats WHERE user1_id = (?) OR user2_id = (?)",
                (user_id, user_id)
            )).fetchone():
                chat_id = user_ids[-1]
                if user_ids[1] is None:
                    return
                if user_ids[0] == user_id:
                    sent_message = await func.send_message(
                        bot,
                        user_ids[1],
                        message,
                        chat_id,
                        media_group
                    )
                else:
                    sent_message = await func.send_message(
                        bot,
                        user_ids[0],
                        message,
                        chat_id,
                        media_group
                    )
                await cursor.execute(
                    """INSERT INTO messages
                    (chat_id, user_id, user_message_id, bot_message_id)
                    VALUES (?, ?, ?, ?)
                    """,
                    (chat_id, user_id, message.message_id, sent_message.message_id)
                )
                await db.commit()


@dp.message_reaction(AnonChatState.in_chat)
async def on_chat_update(message_reaction: types.MessageReactionUpdated):
    user1_id = message_reaction.user.id
    if user1_id == bot.id:
        return
    message_id = message_reaction.message_id
    async with aiosqlite.connect(server_db_path) as db:
        async with db.cursor() as cursor:
            chat_id = (await (await cursor.execute(
                "SELECT id FROM chats "
                "WHERE user2_id = ? "
                "OR user1_id = ?",
                (user1_id, user1_id)
            )).fetchone())[0]
            if await (await cursor.execute(
                "SELECT chat_id FROM messages WHERE bot_message_id = ?",
                (message_id, )
            )).fetchone():
                id_for_reaction, user2_id = (await (await cursor.execute(
                    """SELECT user_message_id, user_id FROM messages WHERE
                    bot_message_id = ?""",
                    (message_id, )
                )).fetchone())
            else:
                users = await (await cursor.execute(
                    "SELECT user1_id, user2_id FROM chats WHERE id = ?",
                    (chat_id, )
                )).fetchone()
                id_for_reaction = (await (await cursor.execute(
                    """SELECT bot_message_id FROM messages WHERE
                    user_message_id = ?""",
                    (message_id, )
                )).fetchone())[0]
                for user in users:
                    if user != user1_id:
                        user2_id = user
    await bot.set_message_reaction(
        user2_id,
        message_id=id_for_reaction,
        reaction=message_reaction.new_reaction
    )


@dp.edited_message(AnonChatState.in_chat)
async def on_chat_edit_message(message: types.Message):
    user1_id = message.from_user.id
    message_id = message.message_id
    async with aiosqlite.connect(server_db_path) as db:
        async with db.cursor() as cursor:
            chat_id = (await (await cursor.execute(
                "SELECT id FROM chats "
                "WHERE user2_id = ? "
                "OR user1_id = ?",
                (user1_id, user1_id)
            )).fetchone())[0]
            users = await (await cursor.execute(
                "SELECT user1_id, user2_id FROM chats WHERE id = ?",
                (chat_id, )
            )).fetchone()
            for user in users:
                if user != user1_id:
                    user2_id = user
            response = (await (await cursor.execute(
                    """SELECT bot_message_id FROM messages WHERE
                    user_message_id = ?""",
                    (message_id, )
                )).fetchone())
            fallback_response_inc = (await (await cursor.execute(
                    """SELECT bot_message_id FROM messages WHERE
                    user_message_id = ?""",
                    (message_id+1, )
                )).fetchone())
            fallback_response_dec = (await (await cursor.execute(
                    """SELECT bot_message_id FROM messages WHERE
                    user_message_id = ?""",
                    (message_id-1, )
                )).fetchone())
            if not response:
                id_to_edit = fallback_response_inc if fallback_response_inc else fallback_response_dec
            else:
                id_to_edit = response
            if not id_to_edit:
                return await message.answer(
                    "–ù–ï –°–û–û–ë–©–ê–ô–¢–ï –û–ë –≠–¢–û–ú –í –ü–û–î–î–ï–†–ñ–ö–£!\n\n"
                    "–ò–∑–º–µ–Ω–µ–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è –¥–ª—è –≤–∞—à–µ–≥–æ —Å–æ–±–µ—Å–µ–¥–µ–Ω–∏–∫–∞ –Ω–µ —É–¥–∞–ª–æ—Å—å.\n"
                    "–≠—Ç–æ –∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞ –∏ –Ω–∞–¥ –µ–µ —Ä–µ—à–µ–Ω–∏–µ–º —É–∂–µ —Ä–∞–±–æ—Ç–∞—é—Ç."
                )
            id_to_edit = id_to_edit[0]
    if message.text:
        await bot.edit_message_text(
            message.text + "\n\n(–†–µ–¥.)",
            chat_id=user2_id,
            message_id=id_to_edit
        )
    elif message.caption:
        await bot.edit_message_caption(
            caption=message.caption + "\n\n(–†–µ–¥.)",
            chat_id=user2_id,
            message_id=id_to_edit,
        )


@dp.callback_query(F.data == "map")
@flags.authorization(is_authorized=True)
async def university_map(callback: types.CallbackQuery):
    await callback.message.answer_photo(
        photo=map_photo,
        caption='üó∫Ô∏è –ö–∞—Ä—Ç–∞ –º–∏–Ω–∏-–≥–æ—Ä–æ–¥–∫–∞ –ë–ù–¢–£',
        reply_markup=keyboards.map_menu()
    )
    await callback.answer()


@dp.callback_query(F.data == "passes")
@flags.authorization(is_authorized=True)
async def passes_button(callback: types.CallbackQuery):
    passes = []
    for i in list(passes):
        b = types.InlineKeyboardButton(
            text=i,
            callback_data=f"get_passes {i}"
        )
        passes.append(b)
    await callback.message.edit_caption(
        caption='üìó –í—ã–±–µ—Ä–∏—Ç–µ –Ω—É–∂–Ω—ã–π –í–∞–º –ø—Ä–µ–¥–º–µ—Ç:',
        reply_markup=keyboards.passes_menu(passes)
    )


@dp.callback_query(F.data.split()[0] == "get_passes")
@flags.authorization(is_authorized=True)
async def pass_button(callback: types.CallbackQuery):
    text = f"{callback.data.split()[1]} | "+passes[callback.data.split()[1]]
    await callback.message.edit_caption(
        caption=text,
        reply_markup=keyboards.pass_detail_menu(), parse_mode="HTML"
    )


@dp.callback_query(F.data == "schedule")
@flags.authorization(is_authorized=True)
async def schedule(callback: types.CallbackQuery):
    try:
        await callback.message.edit_caption(
            caption='üìö –í—ã–±–µ—Ä–∏—Ç–µ –Ω—É–∂–Ω–æ–µ –í–∞–º —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ –∑–∞–Ω—è—Ç–∏–π:',
            reply_markup=keyboards.schedule_menu()
            )
    except Exception:
        await callback.message.delete()
        await callback.message.answer_photo(
            photo=main_menu_image,
            caption='üìö –í—ã–±–µ—Ä–∏—Ç–µ –Ω—É–∂–Ω–æ–µ –í–∞–º —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ –∑–∞–Ω—è—Ç–∏–π:',
            reply_markup=keyboards.schedule_menu()
        )


@dp.callback_query(F.data.split()[0] == "send_schedule")
@flags.authorization(is_authorized=True)
async def schedule(callback: types.CallbackQuery):
    async with aiosqlite.connect(server_db_path) as db:
        async with db.cursor() as cursor:
            student_code = (await (await cursor.execute(
                "SELECT student_code FROM users WHERE id = (?)",
                (callback.from_user.id, )
            )).fetchone())[0]
    group = student_code[:-2]
    with open(f"schedules/schedule_{group}.json", "r", encoding='utf8') as jsonfile:
        schedule_base = json.load(jsonfile)['Schedule']
    if callback.data.split()[1] == 'week':
        date = func.get_week_and_day()
        week, day = date
        text = ''
        for i in schedule_base[week]:
            text += f"\n{i}:\n"
            for j in schedule_base[week][i]:
                teacher_text = ("\n" + j["Teacher"]) if j["Teacher"] else ""
                text += f'<blockquote>{j["Time"]} | {j["Matter"]}\n{j["Frame"]} –∫–æ—Ä–ø., {j["Classroom"]} –∞—É–¥–∏—Ç.{teacher_text}</blockquote>\n'
        await callback.message.delete()
        await callback.message.answer(
            f'{text}',
            reply_markup=keyboards.back_to_schedule(),
            parse_mode="HTML"
        )
    elif callback.data.split()[1] == 'next_week':
        date = func.get_week_and_day()
        week, day = date
        reversing_list = [1, 0]
        week = reversing_list[week]
        text = ''
        for i in schedule_base[week]:
            text += f"\n{i}:\n"
            for j in schedule_base[week][i]:
                teacher_text = ("\n" + j["Teacher"]) if j["Teacher"] else ""
                text += f'<blockquote>{j["Time"]} | {j["Matter"]}\n{j["Frame"]} –∫–æ—Ä–ø., {j["Classroom"]} –∞—É–¥–∏—Ç.{teacher_text}</blockquote>\n'
        await callback.message.delete()
        await callback.message.answer(
            f'{text}',
            reply_markup=keyboards.back_to_schedule(), parse_mode="HTML"
        )
    elif callback.data.split()[1] == 'together':
        date = func.get_week_and_day()
        week, day = date
        text = ''
        try:
            for i in schedule_base[week][day]:
                teacher_text = ("\n" + i["Teacher"]) if i["Teacher"] else ""
                text += f'<blockquote>{i["Time"]} | {i["Matter"]}\n{i["Frame"]} –∫–æ—Ä–ø., {i["Classroom"]} –∞—É–¥–∏—Ç.{teacher_text}</blockquote>\n'
        except KeyError:
            text += "–ó–∞–Ω—è—Ç–∏–π –Ω–µ—Ç üéâ"
        await callback.message.delete()
        await callback.message.answer(
            f'{day}:\n{text}',
            reply_markup=keyboards.back_to_schedule(), parse_mode="HTML"
        )
    elif callback.data.split()[1] == 'tomorrow':
        date = func.get_tomorrow_week_and_day()
        week, day = date
        text = ''
        try:
            for i in schedule_base[week][day]:
                teacher_text = ("\n" + i["Teacher"]) if i["Teacher"] else ""
                text += f'<blockquote>{i["Time"]} | {i["Matter"]}\n{i["Frame"]} –∫–æ—Ä–ø., {i["Classroom"]} –∞—É–¥–∏—Ç.{teacher_text}</blockquote>\n'
        except KeyError:
            text += "–ó–∞–Ω—è—Ç–∏–π –Ω–µ—Ç üéâ"
        await callback.message.delete()
        await callback.message.answer(
            f'{day}:\n{text}',
            reply_markup=keyboards.back_to_schedule(), parse_mode="HTML"
        )


@dp.callback_query(F.data == "delete")
async def delete(callback: types.CallbackQuery):
    await callback.message.delete()


@dp.callback_query(F.data.split()[0] == "help")
@flags.authorization(is_authorized=True)
async def help(callback: types.CallbackQuery):
    await callback.message.delete()
    await callback.message.answer(
        f'–ï—Å–ª–∏ —É –í–∞—Å –µ—Å—Ç—å –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è, –∏–¥–µ–∏ –∏–ª–∏ –í—ã –Ω–∞—à–ª–∏ –±–∞–≥, —Ç–æ –º–æ–∂–µ—Ç–µ —Å–æ–æ–æ–±—â–∏—Ç—å –æ–± —ç—Ç–æ–º, –º—ã –ø–æ—Å—Ç–∞—Ä–∞–µ–º—Å—è –∫–∞–∫ –º–æ–∂–Ω–æ –±—ã—Å—Ç—Ä–µ–µ –æ—Ç–≤–µ—Ç–∏—Ç—å –Ω–∞ –í–∞—à–µ —Å–æ–æ–±—â–µ–Ω–∏–µ.\n\n–û–±—Ä–∞—â–∞—Ç—å—Å—è –ø–æ —é–∑–µ—Ä–Ω–µ–π–º—É {user_owner}',
        reply_markup=keyboards.help_menu()
    )


@dp.message(Command("add_moderator"))
@flags.owner(is_owner=True)
@flags.permissions(any_permission=True)
async def add_moderator(message: types.Message, command: Command):
    if not command.args:
        return message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞ —É–∫–∞–∂–∏—Ç–µ ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è")
    user_id = int(command.args)
    async with aiosqlite.connect(server_db_path) as db:
        async with db.cursor() as cursor:
            student_code = await (await cursor.execute(
                "SELECT student_code FROM users WHERE "
                "id = ?",
                (user_id, )
            )).fetchone()
            if not student_code:
                return await message.answer("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω")
            student_code = student_code[0]
            await cursor.execute(
                "INSERT INTO moderators (id, student_code) VALUES (?, ?)",
                (user_id, student_code)
            )
            await db.commit()
    await message.answer("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–∞–∑–Ω–∞—á–µ–Ω –º–æ–¥–µ—Ä–∞—Ç–æ—Ä–æ–º")


async def main():
    async with aiosqlite.connect(server_db_path) as db:
        async with db.cursor() as cursor:
            await cursor.execute("""CREATE TABLE IF NOT EXISTS users(
                id INT PRIMARY KEY,
                FullName TEXT,
                faculty TEXT,
                student_code TEXT,
                code TEXT UNIQUE
            )""")
            await cursor.execute("""CREATE TABLE IF NOT EXISTS chats(
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user1_id INT NOT NULL,
                user2_id INT
            )""")
            await cursor.execute("""CREATE TABLE IF NOT EXISTS messages(
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                chat_id INTEGER NOT NULL,
                user_id INTEGER NOT NULL,
                user_message_id INTEGER NOT NULL,
                bot_message_id INTEGER NOT NULL,
                FOREIGN KEY (chat_id) REFERENCES chats(id)
            )""")
            await cursor.execute("""CREATE TABLE IF NOT EXISTS bans_anon_chat(
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                FOREIGN KEY (user_id) REFERENCES users(id)
            )""")
            await cursor.execute("""CREATE TABLE IF NOT EXISTS moderators(
                id INT PRIMARY KEY,
                student_code TEXT NOT NULL,
                hired_at DATETIME DEFAULT (datetime('now', 'localtime')),
                FOREIGN KEY (student_code) REFERENCES users(student_code)
            )""")

        await db.commit()
    me = await bot.get_me()
    logger.info(f"@{me.username} ({me.first_name})")
    dp.message.middleware(middleware.AuthorizationMiddleware())
    dp.callback_query.middleware(middleware.AuthorizationMiddleware())
    dp.message.middleware(middleware.BanMiddleware())
    dp.callback_query.middleware(middleware.BanMiddleware())
    dp.message.middleware(middleware.OwnerMiddleware())
    dp.callback_query.middleware(middleware.OwnerMiddleware())
    dp.message.middleware(middleware.ModeratorMiddleware())
    dp.callback_query.middleware(middleware.ModeratorMiddleware())
    dp.message.middleware(middleware.PermissonMiddleware())
    dp.callback_query.middleware(middleware.PermissonMiddleware())
    dp.update.middleware(middleware.MediaGroupMiddleware())
    await dp.start_polling(bot)

if __name__ == "__main__":
    asyncio.run(main())
